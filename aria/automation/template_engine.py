"""Template engine — composes trigger + condition + action into full HA automation.

Coordinates the three builders (trigger, condition, action) and adds
mode selection, alias/description generation, and unique ID assignment.
"""

import hashlib

from aria.automation.action_builder import build_actions
from aria.automation.condition_builder import build_conditions
from aria.automation.models import DetectionResult
from aria.automation.trigger_builder import build_trigger

# Mode selection rules — domain prefixes that override the default
QUEUED_DOMAINS = frozenset({"notify"})
PARALLEL_DOMAINS = frozenset({"scene"})


class AutomationTemplate:
    """Composes a full HA automation dict from a DetectionResult."""

    def __init__(self, entity_graph: object) -> None:
        self._entity_graph = entity_graph

    def build(self, detection: DetectionResult) -> dict:
        """Build a complete HA automation dict.

        Calls trigger, condition, and action builders, then wraps with
        mode, alias, description, and a unique ID.

        Args:
            detection: The detection result to generate an automation for.

        Returns:
            Complete HA-compatible automation dict.
        """
        trigger = build_trigger(detection)
        conditions = build_conditions(detection, self._entity_graph)
        actions = build_actions(detection, self._entity_graph)

        automation_id = _generate_id(detection)
        alias = _generate_alias(detection)
        description = _generate_description(detection)
        mode = _select_mode(detection)

        return {
            "id": automation_id,
            "alias": alias,
            "description": description,
            "triggers": [trigger],
            "conditions": conditions,
            "actions": actions,
            "mode": mode,
        }


def _generate_id(detection: DetectionResult) -> str:
    """Generate a unique, deterministic automation ID."""
    # Combine trigger + action entities for uniqueness
    parts = [detection.trigger_entity] + sorted(detection.action_entities)
    if detection.day_type:
        parts.append(detection.day_type)
    raw = "|".join(parts)
    suffix = hashlib.md5(raw.encode()).hexdigest()[:8]  # noqa: S324

    # Human-readable prefix from trigger entity
    trigger_name = detection.trigger_entity.split(".", 1)[-1]
    return f"aria_{trigger_name}_{suffix}"


def _generate_alias(detection: DetectionResult) -> str:
    """Generate a human-readable alias for the automation."""
    trigger_name = _humanize_entity(detection.trigger_entity)
    action_names = [_humanize_entity(e) for e in detection.action_entities[:2]]
    action_str = " and ".join(action_names)

    area_prefix = ""
    if detection.area_id:
        area_prefix = f"{detection.area_id.replace('_', ' ').title()}: "

    return f"{area_prefix}{trigger_name} → {action_str}"


def _generate_description(detection: DetectionResult) -> str:
    """Generate a description with metadata about the detection."""
    source = detection.source.title()
    confidence_pct = int(detection.confidence * 100)

    lines = [
        f"Generated by ARIA {source} engine.",
        f"Confidence: {confidence_pct}%, observed {detection.observation_count} times.",
        f"Active: {detection.first_seen} to {detection.last_seen}.",
    ]
    if detection.day_type != "all":
        lines.append(f"Day type: {detection.day_type}.")

    return " ".join(lines)


def _select_mode(detection: DetectionResult) -> str:
    """Select automation mode based on action domains."""
    for entity in detection.action_entities:
        domain = entity.split(".")[0]
        if domain in QUEUED_DOMAINS:
            return "queued"
        if domain in PARALLEL_DOMAINS:
            return "parallel"
    return "single"


def _humanize_entity(entity_id: str) -> str:
    """Convert entity_id to human-readable name."""
    name = entity_id.split(".", 1)[-1]
    return name.replace("_", " ").title()
