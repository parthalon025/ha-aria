"""Unit tests for OrchestratorModule.

Tests delegation to AutomationGeneratorModule, safety guardrails,
approval/rejection flow, cache interaction, lifecycle, and event handling.

Task 28: Orchestrator thinning — _pattern_to_suggestion and _signals_to_actions
removed; generate_suggestions delegates to AutomationGeneratorModule.
"""

import sys
from datetime import datetime
from pathlib import Path
from typing import Any
from unittest.mock import AsyncMock, MagicMock

import pytest

sys.path.insert(0, str(Path(__file__).parent.parent))

from aria.modules.orchestrator import OrchestratorModule

# ============================================================================
# Mock Hub
# ============================================================================


class MockHub:
    """Lightweight hub mock for orchestrator tests."""

    def __init__(self):
        self._cache: dict[str, dict[str, Any]] = {}
        self._running = True
        self._scheduled_tasks: list[dict[str, Any]] = []
        self._published_events: list[dict[str, Any]] = []
        self.logger = MagicMock()
        self.modules = {}

    async def set_cache(self, category: str, data: Any, metadata: dict | None = None):
        self._cache[category] = {
            "data": data,
            "metadata": metadata,
            "last_updated": datetime.now().isoformat(),
        }

    async def get_cache(self, category: str) -> dict[str, Any] | None:
        return self._cache.get(category)

    async def get_cache_fresh(self, category: str, max_age=None, caller="") -> dict[str, Any] | None:
        return self._cache.get(category)

    def is_running(self) -> bool:
        return self._running

    async def schedule_task(self, **kwargs):
        self._scheduled_tasks.append(kwargs)

    def register_module(self, mod):
        self.modules[mod.module_id] = mod

    async def publish(self, event_type: str, data: dict[str, Any]):
        self._published_events.append({"event_type": event_type, "data": data})


# ============================================================================
# Mock AutomationGeneratorModule
# ============================================================================


class MockAutomationGenerator:
    """Mock for the AutomationGeneratorModule used by delegation."""

    def __init__(self, suggestions=None):
        self.suggestions = suggestions or []
        self.generate_suggestions = AsyncMock(return_value=self.suggestions)


# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def hub():
    return MockHub()


@pytest.fixture
def module(hub):
    """Create an OrchestratorModule with mock hub and dummy HA credentials."""
    return OrchestratorModule(
        hub=hub,
        ha_url="http://localhost:8123",
        ha_token="fake-token",
        min_confidence=0.7,
    )


def make_suggestion(
    suggestion_id="sug_001",
    status="pending",
    automation_yaml=None,
    pattern_id="pattern_1",
):
    """Helper to build a suggestion dictionary."""
    return {
        "suggestion_id": suggestion_id,
        "pattern_id": pattern_id,
        "automation_yaml": automation_yaml
        or {
            "alias": "Test Automation",
            "description": "Generated by ARIA",
            "trigger": [{"platform": "state", "entity_id": "binary_sensor.motion"}],
            "condition": [],
            "action": [{"service": "light.turn_on", "target": {"entity_id": "light.kitchen"}}],
        },
        "status": status,
        "combined_score": 0.65,
        "source": "pattern",
        "created_at": datetime.now().isoformat(),
    }


# ============================================================================
# Initialization & Lifecycle
# ============================================================================


class TestInitialization:
    """Test module constructor and init/shutdown lifecycle."""

    def test_module_id(self, module):
        """Module ID should be 'orchestrator'."""
        assert module.module_id == "orchestrator"

    def test_constructor_stores_config(self, module):
        """Constructor stores HA URL, token, and min_confidence."""
        assert module.ha_url == "http://localhost:8123"
        assert module.ha_token == "fake-token"
        assert module.min_confidence == 0.7

    def test_constructor_strips_trailing_slash(self, hub):
        """HA URL trailing slash is stripped."""
        mod = OrchestratorModule(hub, "http://ha:8123/", "token")
        assert mod.ha_url == "http://ha:8123"

    def test_default_min_confidence(self, hub):
        """Default min_confidence is 0.7."""
        mod = OrchestratorModule(hub, "http://ha:8123", "token")
        assert mod.min_confidence == 0.7

    @pytest.mark.asyncio
    async def test_initialize_creates_http_session(self, module, hub):
        """initialize() creates an aiohttp ClientSession."""
        await module.initialize()

        assert module._session is not None
        # Verify scheduled task was registered
        assert len(hub._scheduled_tasks) == 1
        assert hub._scheduled_tasks[0]["task_id"] == "orchestrator_suggestions"

        await module.shutdown()

    @pytest.mark.asyncio
    async def test_initialize_handles_suggestion_failure(self, module, hub):
        """initialize() logs error but doesn't crash if suggestion generation fails."""
        # No automation_generator module and no cache → returns []
        await module.initialize()

        # Initialization succeeded — session was created
        assert module._session is not None
        # Scheduled task was still registered
        assert len(hub._scheduled_tasks) == 1

        await module.shutdown()

    @pytest.mark.asyncio
    async def test_shutdown_closes_session(self, module, hub):
        """shutdown() closes the HTTP session and sets it to None."""
        await module.initialize()
        assert module._session is not None

        await module.shutdown()
        assert module._session is None

    @pytest.mark.asyncio
    async def test_shutdown_without_initialize(self, module):
        """shutdown() is safe to call without initialize."""
        await module.shutdown()
        assert module._session is None


# ============================================================================
# Delegation to AutomationGeneratorModule (Task 28)
# ============================================================================


class TestDelegation:
    """Test that generate_suggestions delegates to AutomationGeneratorModule."""

    @pytest.mark.asyncio
    async def test_delegates_to_generator_module(self, module, hub):
        """When automation_generator is registered, delegates to it."""
        mock_gen = MockAutomationGenerator(suggestions=[make_suggestion()])
        hub.modules["automation_generator"] = mock_gen

        result = await module.generate_suggestions()

        mock_gen.generate_suggestions.assert_awaited_once()
        assert len(result) == 1

    @pytest.mark.asyncio
    async def test_returns_generator_results(self, module, hub):
        """Returns whatever the generator module returns."""
        suggestions = [make_suggestion("s1"), make_suggestion("s2")]
        mock_gen = MockAutomationGenerator(suggestions=suggestions)
        hub.modules["automation_generator"] = mock_gen

        result = await module.generate_suggestions()
        assert len(result) == 2
        assert result[0]["suggestion_id"] == "s1"

    @pytest.mark.asyncio
    async def test_fallback_reads_cache_when_no_generator(self, module, hub):
        """Without automation_generator module, reads cache directly."""
        await hub.set_cache(
            "automation_suggestions",
            {"suggestions": [make_suggestion("cached_1")]},
        )

        result = await module.generate_suggestions()
        assert len(result) == 1
        assert result[0]["suggestion_id"] == "cached_1"

    @pytest.mark.asyncio
    async def test_fallback_returns_empty_when_no_cache(self, module, hub):
        """Without generator or cache, returns empty list."""
        result = await module.generate_suggestions()
        assert result == []

    @pytest.mark.asyncio
    async def test_pattern_to_suggestion_removed(self, module):
        """_pattern_to_suggestion method no longer exists (Task 28)."""
        assert not hasattr(module, "_pattern_to_suggestion")

    @pytest.mark.asyncio
    async def test_signals_to_actions_removed(self, module):
        """_signals_to_actions method no longer exists (Task 28)."""
        assert not hasattr(module, "_signals_to_actions")


# ============================================================================
# Safety Guardrails
# ============================================================================


class TestSafetyGuardrails:
    """Test _check_safety_guardrails for restricted domains."""

    def test_restricted_lock_domain(self, module):
        """lock.* service requires explicit approval."""
        actions = [{"service": "lock.lock", "target": {"entity_id": "lock.front_door"}}]
        assert module._check_safety_guardrails(actions) is True

    def test_restricted_cover_domain(self, module):
        """cover.* service requires explicit approval."""
        actions = [{"service": "cover.close_cover", "target": {}}]
        assert module._check_safety_guardrails(actions) is True

    def test_restricted_alarm_domain(self, module):
        """alarm_control_panel.* requires explicit approval."""
        actions = [{"service": "alarm_control_panel.arm_away", "target": {}}]
        assert module._check_safety_guardrails(actions) is True

    def test_safe_light_domain(self, module):
        """light.* does not require explicit approval."""
        actions = [{"service": "light.turn_on", "target": {}}]
        assert module._check_safety_guardrails(actions) is False

    def test_safe_notification_domain(self, module):
        """notify.* does not require explicit approval."""
        actions = [{"service": "notify.persistent_notification", "data": {}}]
        assert module._check_safety_guardrails(actions) is False

    def test_empty_actions(self, module):
        """Empty actions list is safe."""
        assert module._check_safety_guardrails([]) is False

    def test_mixed_safe_and_restricted(self, module):
        """If any action is restricted, the whole set is restricted."""
        actions = [
            {"service": "light.turn_on", "target": {}},
            {"service": "lock.lock", "target": {}},
        ]
        assert module._check_safety_guardrails(actions) is True

    def test_no_service_key(self, module):
        """Actions without 'service' key are treated as safe."""
        actions = [{"data": {"message": "test"}}]
        assert module._check_safety_guardrails(actions) is False


# ============================================================================
# Approval Flow
# ============================================================================


class TestApprovalFlow:
    """Test approve_suggestion and reject_suggestion."""

    @pytest.mark.asyncio
    async def test_approve_creates_automation(self, module, hub):
        """Approving a suggestion calls _create_automation and updates status."""
        # Seed suggestions directly in cache
        suggestion = make_suggestion("sug_approve")
        await hub.set_cache(
            "automation_suggestions",
            {"suggestions": [suggestion], "count": 1},
        )

        # Mock _create_automation to succeed
        module._create_automation = AsyncMock(
            return_value={
                "success": True,
                "automation_id": "pattern_sug_approve",
            }
        )
        module._session = MagicMock()

        result = await module.approve_suggestion("sug_approve")

        assert result["success"] is True
        assert result["automation_id"] == "pattern_sug_approve"

        # Verify event published
        approval_events = [e for e in hub._published_events if e["event_type"] == "automation_approved"]
        assert len(approval_events) == 1

    @pytest.mark.asyncio
    async def test_approve_nonexistent_suggestion(self, module, hub):
        """Approving a nonexistent suggestion returns error."""
        await hub.set_cache("automation_suggestions", {"suggestions": []})

        result = await module.approve_suggestion("nonexistent")
        assert result["success"] is False
        assert "not found" in result["error"]

    @pytest.mark.asyncio
    async def test_approve_already_approved(self, module, hub):
        """Approving an already-approved suggestion returns error."""
        await hub.set_cache(
            "automation_suggestions",
            {
                "suggestions": [
                    {
                        "suggestion_id": "abc",
                        "pattern_id": "p1",
                        "status": "approved",
                        "automation_id": "pattern_abc",
                        "automation_yaml": {},
                    }
                ]
            },
        )

        result = await module.approve_suggestion("abc")
        assert result["success"] is False
        assert "already approved" in result["error"]

    @pytest.mark.asyncio
    async def test_approve_no_cache_returns_error(self, module, hub):
        """Approving with no suggestion cache returns error."""
        result = await module.approve_suggestion("abc")
        assert result["success"] is False

    @pytest.mark.asyncio
    async def test_reject_suggestion(self, module, hub):
        """Rejecting a suggestion updates status and publishes event."""
        await hub.set_cache(
            "automation_suggestions",
            {
                "suggestions": [
                    {
                        "suggestion_id": "abc",
                        "pattern_id": "p1",
                        "status": "pending",
                        "automation_yaml": {},
                    }
                ]
            },
        )

        result = await module.reject_suggestion("abc")
        assert result["success"] is True

        # Verify status updated in cache
        cached = await hub.get_cache("automation_suggestions")
        assert cached["data"]["suggestions"][0]["status"] == "rejected"

        # Verify event published
        rejection_events = [e for e in hub._published_events if e["event_type"] == "automation_rejected"]
        assert len(rejection_events) == 1

    @pytest.mark.asyncio
    async def test_reject_nonexistent_suggestion(self, module, hub):
        """Rejecting a nonexistent suggestion returns error."""
        await hub.set_cache("automation_suggestions", {"suggestions": []})

        result = await module.reject_suggestion("nonexistent")
        assert result["success"] is False
        assert "not found" in result["error"]


# ============================================================================
# Event Handling
# ============================================================================


class TestEventHandling:
    """Test on_event triggering suggestion regeneration."""

    @pytest.mark.asyncio
    async def test_patterns_cache_update_triggers_regeneration(self, module, hub):
        """cache_updated event for 'patterns' triggers generate_suggestions."""
        mock_gen = MockAutomationGenerator(suggestions=[make_suggestion()])
        hub.modules["automation_generator"] = mock_gen

        await module.on_event("cache_updated", {"category": "patterns"})

        mock_gen.generate_suggestions.assert_awaited_once()

    @pytest.mark.asyncio
    async def test_non_patterns_cache_update_ignored(self, module, hub):
        """cache_updated for other categories does not trigger regeneration."""
        mock_gen = MockAutomationGenerator()
        hub.modules["automation_generator"] = mock_gen

        await module.on_event("cache_updated", {"category": "entities"})

        mock_gen.generate_suggestions.assert_not_awaited()

    @pytest.mark.asyncio
    async def test_non_cache_event_ignored(self, module, hub):
        """Non cache_updated events are ignored."""
        mock_gen = MockAutomationGenerator()
        hub.modules["automation_generator"] = mock_gen

        await module.on_event("state_changed", {"entity_id": "light.kitchen"})

        mock_gen.generate_suggestions.assert_not_awaited()

    @pytest.mark.asyncio
    async def test_event_handler_error_does_not_crash(self, module, hub):
        """Errors during event-driven regeneration are caught."""
        # No automation_generator and no cache → returns [] without crashing
        await module.on_event("cache_updated", {"category": "patterns"})


# ============================================================================
# Get Suggestions
# ============================================================================


class TestGetSuggestions:
    """Test get_suggestions with status filtering."""

    @pytest.mark.asyncio
    async def test_get_all_suggestions(self, module, hub):
        """get_suggestions() returns all suggestions without filter."""
        await hub.set_cache(
            "automation_suggestions",
            {
                "suggestions": [
                    {"suggestion_id": "a", "status": "pending"},
                    {"suggestion_id": "b", "status": "approved"},
                ]
            },
        )

        result = await module.get_suggestions()
        assert len(result) == 2

    @pytest.mark.asyncio
    async def test_get_pending_only(self, module, hub):
        """get_suggestions(status_filter='pending') returns only pending."""
        await hub.set_cache(
            "automation_suggestions",
            {
                "suggestions": [
                    {"suggestion_id": "a", "status": "pending"},
                    {"suggestion_id": "b", "status": "approved"},
                ]
            },
        )

        result = await module.get_suggestions(status_filter="pending")
        assert len(result) == 1
        assert result[0]["suggestion_id"] == "a"

    @pytest.mark.asyncio
    async def test_get_suggestions_empty_cache(self, module, hub):
        """get_suggestions() returns empty list when no cache exists."""
        result = await module.get_suggestions()
        assert result == []


# ============================================================================
# Created Automations Tracking
# ============================================================================


class TestCreatedAutomations:
    """Test get_created_automations tracking."""

    @pytest.mark.asyncio
    async def test_get_created_automations_empty(self, module, hub):
        """Returns empty dict when no automations tracked."""
        result = await module.get_created_automations()
        assert result == {}

    @pytest.mark.asyncio
    async def test_track_and_retrieve(self, module, hub):
        """_track_created_automation stores and get_created_automations retrieves."""
        await module._track_created_automation("pattern_abc", "suggestion_abc")

        result = await module.get_created_automations()
        assert "pattern_abc" in result
        assert result["pattern_abc"]["suggestion_id"] == "suggestion_abc"
        assert result["pattern_abc"]["status"] == "active"


# ============================================================================
# HTTP Automation Creation
# ============================================================================


class TestCreateAutomation:
    """Test _create_automation HTTP interaction."""

    @pytest.mark.asyncio
    async def test_successful_creation(self, module, hub):
        """HTTP 200 returns success."""
        mock_resp = AsyncMock()
        mock_resp.status = 200
        mock_resp.__aenter__ = AsyncMock(return_value=mock_resp)
        mock_resp.__aexit__ = AsyncMock(return_value=False)

        mock_session = MagicMock()
        mock_session.post = MagicMock(return_value=mock_resp)
        module._session = mock_session

        result = await module._create_automation("test_id", {"alias": "Test"})
        assert result["success"] is True

    @pytest.mark.asyncio
    async def test_401_stores_for_manual_creation(self, module, hub):
        """HTTP 401 stores automation for manual creation (still returns success)."""
        mock_resp = AsyncMock()
        mock_resp.status = 401
        mock_resp.__aenter__ = AsyncMock(return_value=mock_resp)
        mock_resp.__aexit__ = AsyncMock(return_value=False)

        mock_session = MagicMock()
        mock_session.post = MagicMock(return_value=mock_resp)
        module._session = mock_session

        result = await module._create_automation("test_id", {"alias": "Test"})
        assert result["success"] is True
        assert result["manual_creation_required"] is True

    @pytest.mark.asyncio
    async def test_500_returns_failure(self, module, hub):
        """HTTP 500 returns failure with error message."""
        mock_resp = AsyncMock()
        mock_resp.status = 500
        mock_resp.text = AsyncMock(return_value="Internal Server Error")
        mock_resp.__aenter__ = AsyncMock(return_value=mock_resp)
        mock_resp.__aexit__ = AsyncMock(return_value=False)

        mock_session = MagicMock()
        mock_session.post = MagicMock(return_value=mock_resp)
        module._session = mock_session

        result = await module._create_automation("test_id", {"alias": "Test"})
        assert result["success"] is False
        assert "500" in result["error"]

    @pytest.mark.asyncio
    async def test_network_error_returns_failure(self, module, hub):
        """Network error returns failure."""
        import aiohttp

        mock_session = MagicMock()
        mock_session.post = MagicMock(side_effect=aiohttp.ClientError("Connection refused"))
        module._session = mock_session

        result = await module._create_automation("test_id", {"alias": "Test"})
        assert result["success"] is False
        assert "Network error" in result["error"]


# ============================================================================
# Pending Automations Storage
# ============================================================================


class TestPendingAutomations:
    """Test _store_pending_automation cache behavior."""

    @pytest.mark.asyncio
    async def test_stores_pending_automation(self, module, hub):
        """Stores automation YAML in pending_automations cache."""
        await module._store_pending_automation("auto_1", {"alias": "Test"})

        cached = await hub.get_cache("pending_automations")
        assert cached is not None
        assert "auto_1" in cached["data"]["automations"]
        assert cached["data"]["automations"]["auto_1"]["yaml"]["alias"] == "Test"

    @pytest.mark.asyncio
    async def test_appends_to_existing_pending(self, module, hub):
        """Multiple pending automations accumulate in cache."""
        await module._store_pending_automation("auto_1", {"alias": "First"})
        await module._store_pending_automation("auto_2", {"alias": "Second"})

        cached = await hub.get_cache("pending_automations")
        assert len(cached["data"]["automations"]) == 2


# ============================================================================
# Pattern Detection Sensor
# ============================================================================


class TestPatternSensor:
    """Test update_pattern_detection_sensor HA API call."""

    @pytest.mark.asyncio
    async def test_sensor_update_success(self, module):
        """Successful sensor update posts to HA states API."""
        mock_resp = AsyncMock()
        mock_resp.status = 200
        mock_resp.__aenter__ = AsyncMock(return_value=mock_resp)
        mock_resp.__aexit__ = AsyncMock(return_value=False)

        mock_session = MagicMock()
        mock_session.post = MagicMock(return_value=mock_resp)
        module._session = mock_session

        await module.update_pattern_detection_sensor("Evening Routine", "p1", 0.9)

        mock_session.post.assert_called_once()
        call_args = mock_session.post.call_args
        assert "sensor.ha_hub_pattern_detected" in call_args[0][0]

    @pytest.mark.asyncio
    async def test_sensor_update_failure_does_not_crash(self, module):
        """Sensor update failure is logged but doesn't raise."""
        mock_session = MagicMock()
        mock_session.post = MagicMock(side_effect=Exception("Network error"))
        module._session = mock_session

        # Should not raise
        await module.update_pattern_detection_sensor("Test", "p1", 0.5)


# ============================================================================
# Immediate Cache Update on Approval (Task 26)
# ============================================================================


class TestImmediateCacheUpdateOnApproval:
    """Test that approved automations are immediately added to ha_automations cache."""

    @pytest.mark.asyncio
    async def test_approval_updates_ha_automations_cache(self, module, hub):
        """Approving a suggestion adds the automation to ha_automations cache."""
        suggestion = make_suggestion("sug_ha_cache")
        await hub.set_cache(
            "automation_suggestions",
            {"suggestions": [suggestion], "count": 1},
        )

        module._create_automation = AsyncMock(
            return_value={
                "success": True,
                "automation_id": "pattern_sug_ha_cache",
            }
        )
        module._session = MagicMock()

        result = await module.approve_suggestion("sug_ha_cache")
        assert result["success"] is True

        # Verify ha_automations cache was updated
        ha_cache = await hub.get_cache("ha_automations")
        assert ha_cache is not None
        automations = ha_cache["data"]["automations"]
        assert len(automations) >= 1
        auto_ids = [a.get("id") for a in automations]
        assert "pattern_sug_ha_cache" in auto_ids

    @pytest.mark.asyncio
    async def test_approval_preserves_existing_ha_automations(self, module, hub):
        """Approving a suggestion doesn't remove existing ha_automations."""
        # Pre-populate ha_automations cache
        await hub.set_cache(
            "ha_automations",
            {
                "automations": [
                    {"id": "existing_auto", "alias": "Existing", "trigger": [], "action": [], "condition": []},
                ],
                "count": 1,
                "last_sync": "2026-01-01T00:00:00",
            },
        )

        suggestion = make_suggestion("sug_preserve")
        await hub.set_cache(
            "automation_suggestions",
            {"suggestions": [suggestion], "count": 1},
        )

        module._create_automation = AsyncMock(
            return_value={
                "success": True,
                "automation_id": "pattern_sug_preserve",
            }
        )
        module._session = MagicMock()

        await module.approve_suggestion("sug_preserve")

        ha_cache = await hub.get_cache("ha_automations")
        automations = ha_cache["data"]["automations"]
        assert len(automations) == 2
        auto_ids = [a.get("id") for a in automations]
        assert "existing_auto" in auto_ids
        assert "pattern_sug_preserve" in auto_ids

    @pytest.mark.asyncio
    async def test_approval_cache_update_on_failed_creation_still_tracks(self, module, hub):
        """When automation creation fails, ha_automations cache is NOT updated."""
        suggestion = make_suggestion("sug_fail")
        await hub.set_cache(
            "automation_suggestions",
            {"suggestions": [suggestion], "count": 1},
        )

        module._create_automation = AsyncMock(
            return_value={
                "success": False,
                "error": "HTTP 500",
            }
        )
        module._session = MagicMock()

        result = await module.approve_suggestion("sug_fail")
        assert result["success"] is False

        # ha_automations cache should NOT be updated on failure
        ha_cache = await hub.get_cache("ha_automations")
        assert ha_cache is None
